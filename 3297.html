<!DOCTYPE html>
<html lang="en">
	<head>
		<link rel="stylesheet" href="style.css">
		<style>
			body {
				font-size: 8px !important;
				letter-spacing: -0.3px;
				line-height: 88%;
			}

			h1 {
				font-size: 8px !important;
			}
		</style>
	</head>
	<body>
		<div>
			<h1>Intro</h1>
			<p>
				<span class="semibold">Software engineering</span>
				economies of all developed nations are dependent on software;
				concerned with theories, methods &amp; tools for professional software development
				<span class="semibold">Software costs</span>
				often dominate computer system costs; software costs on a PC are often greater than hardware costs;
				maintenance costs more than development; software engineering is concerned with cost-effective software development
				<br>
				<span class="semibold">Professional software development</span>
				software definition: computer programs &amp; associated documentation (might be generic/customized);
				Essential good software attributes: maintainability, dependability(security), efficiency,
				acceptability (to the type of users it is designed for; must be understandable, usable &amp; compatible with other systems)
				<br>
				<span class="semibold">Product specification</span>
				specification of what the software should do; decisions on software change are made by the owners
				(developers for generic, customers for customized)
				<br>
				<span class="semibold">Software engineering</span>
				an engineering discipline that is concerned with all aspects of software production from the early stages
				of system specification through to maintaining the system after it has gone into use;
				importance: need to produce reliable and trustworthy systems economically and quickly;
				usually cheaper to use software engineering methods and techniques for software systems;
				<span class="semibold">Process activities</span> specification, development, validation, evolution;
				<span class="semibold">General issues</span> heterogeneity(compatibility), business &amp;
				social (environment) change, security &amp; trust, scale;
				<span class="semibold">Diversity</span>
				engineering methods/tools used depend on: application type, customer requirements, dev team background;
				Application types: stand-alone (no network required) apps, interactive transaction-based apps,
				embedded control systems (for hardwares), batch (data) processing systems, entertainment systems,
				modelling &amp; simulation systems, data collection systems, systems of systems
				<span class="semibold">Fundamentals</span> Use a managed and understood development process;
				Dependability and performance; Understanding and managing the software specification and requirements;
				Reuse software when appropriate
				<span class="semibold">Ethics</span> Confidentiality (whether or not a formal confidentiality agreement has been signed)
				&amp; Competence (should not misrepresent their competence level);
				Issues: IP rights, computer misuse
			</p>
			<hr>
			<h1>Software processes</h1>
			<p>
			structured set of activities required to develop a software system;
			involving: Specification, Design &amp; implementation, Validation, Evolution;
			description: activities &amp; ordering, products, roles, pre-/post-conditions;
			<span class="semibold">Plan-driven &amp; agile processes</span>
			Plan-driven: all activities planned in advance, progress is measured against the plan;
			Agile: incremental planning;
			most practical processes include elements of both;
			<br>
			<span class="semibold">Models</span> waterfall: plan-driven, separate and distinct phases of specification &amp; development;
			drawbacks: difficulty of accommodating change, freezing software specification too early, inflexible project partitioning;
			mostly for large systems developed at several sites;
			incremental: interleaved specification, development &amp; validation;
			benefits: good for accommodating changing customer requirements; easier to get customer feedback;
			earlier use &amp; value from software;
			problems: process not visible (regular deliverables required; expensive documentation for quick development);
			structure degrade (needs refactoring);
			integration &amp; configuration: systems are integrated from existing components or application systems, elements can be configured;
			(reusable element types: stand-alone app system, components(collection of objects/web services))
			Pros: lower costs &amp; risks, faster delivery and deployment;
			Cons: may not meet real needs of users, no control over evolution of reused elements
			<br>
			<span class="semibold">Changes</span> (business changes, new technologies, changing platforms)
			cost of change = rework + new functionalities;
			Reducing rework costs: change anticipation, change tolerance
			<br>
			<span class="semibold">Prototyping</span>
			an initial version of a system for demonstrating concepts &amp; testing design options;
			can help with requirements elicitation/validation and developing UI design;
			benefits: improved system usability, closer match to users' real needs, improved design quality,
			improved maintainability, reduced development effort;
			<span class="semibold">Process</span> prototyping plan, outline definition, executable prototype, evaluation report;
			prototypes should be discarded after development as they are not a good basis for a production system
			<br>
			<span class="semibold">Incremental delivery</span> development and delivery is broken down into increments,
			each delivering part of the required functionality; (prioritized user requirements)
			pros: system functionality is available earlier;
			early increments act as a prototype, help to elicit requirements for later increments;
			lower risk of overall project failure;
			highest priority services tend to receive the most testing;
			cons: most systems require a set of basic facilities; conflicts with the procurement model of many organizations;
			<br>
			<span class="semibold">Process improvement</span> a way of enhancing software quality, reducing costs &amp; accelerating development;
			requires understanding existing processes and changing them;
			Approaches: process maturity (quality &amp; predictability), agile (rapid delivery &amp; responsiveness);
			Cycle: measure, analyze, change; Metrics: development time, resources, number of occurrences of a particular event
			</p>
			<hr>
			<h1>Agile development</h1>
			Background: Rapid development and delivery is often the most important requirement for software systems;
			Features: incremental delivery involving stakeholders, frequent delivery, extensive tool support, minimal documentation;
			Principles: Customer involvement, Incremental delivery, People not process, Embrace change, Maintain simplicity;
			Applicability: small or medium-sized product for sale; within an organization, with a clear customer commitment &amp;
			few external rules and regulations;
			<br>
			<span class="semibold">Extreme programming</span> practices: Incremental planning (Requirements are recorded on story cards,
			determined by the time available and relative priority, break stories into development tasks),
			Small releases (frequent &amp; incremental), Simple design (focus on current requirements only),
			Test-first development (tests before implementation), Refactoring (improve code as soon as possible, keeping code simple),
			Pair programming, Collective ownership (everyone works on all areas together, anyone can change anything),
			Continuous integration (integrate completed task into whole system),
			Sustainable pace (do not accept large amount of overtime),
			On-site customer (a representative of end-user/customer in team available full time)
			<br>
			<span class="semibold">Scrum</span> Phases: outline planning, sprint cycles (increments), wrap-up;
			Members: dev team (group of self-organizing software developers, develop softwares &amp; essential documents),
			scrum master (ensure Scrum process is followed, guide the team to use Scrum effectively, interface with rest of the company),
			product owner (individual/small group, identify & prioritize product features or requirements,
			continuously review product backlog)
			Cycle: list to do items on backlog (involves all of the project team);
			product owner prioritizes the items in product backlog, dev team selects &amp; develops the items;
			(scrum board: forecast(user stories), to-do, in-progress, done)
			daily meeting of the project team, reviewing progress and prioritizing work;
			(end of development and testing) review meeting, update backlog, present to stakeholders, process improvement;
			scrum benefits: breaks project down to manageable &amp; understandable chunks;
			unstable requirements do not hold up progress;
			whole team have visibility of everything &amp; improved communication;
			customers see on-time incremental delivery &amp; give feedback;
			trust between customers and developers, creates positive culture
			<br>
			<span class="semibold">Scaling agile methods</span>
			Scaling up: large software systems; Scaling out: across a large organization;
			<span class="semibold">Practical problems</span> incompatible with the legal approach to contract definition;
			not good for software maintenance (lack of documentation, customer involvement, dev team continuity);
			methods were designed for small co-located teams;
			completely incremental requirements engineering is impossible;
			there cannot be a single product owner/customer representative;
			impossible to focus only on the system code;
			cross-team communication mechanisms required;
			practically impossible continuous integration
			<hr>
			<h1>Requirements engineering</h1>
			<p>
			process of establishing the services a customer requires for a system &amp; the constraints it operates and is developed under;
			(System requirements: descriptions of the system services and constraints generated during the requirements engineering process)
			Requirements may be: the basis for a bid for a contract (must be open to interpretation) &amp;
			the basis for the contract itself (must be defined in detail)
			<span class="semibold">Requirement types</span>
			User requirements (natural language statements + diagrams of the system's services and operational constraints,
			mainly for customers),
			System requirements (structured document with detailed descriptions of the system's functions, services &amp;
			operational constraints)
			<br>
			<span class="semibold">System stakeholders</span> person/organization who affects/is affected by the system in some way,
			therefore having a legitimate interest (types: End users, System managers, System owners, External stakeholders)
			<br>
			<span class="semibold">Functional requirements</span>
			Statements of services the system should provide / how the system should react to particular inputs /
			how the system should behave in particular situations (May state what the system should not do);
			Depend on the type of software, expected users and the system type where the software is used;
			User requirements may be high-level statements of what the system should do;
			System requirements should describe the system services in detail;
			(problems: imprecision, incompleteness, inconsistency)
			<span class="semibold">Non-functional requirements</span>
			define system properties and constraints (e.g. reliability, response time, storage requirement,
			I/O device capability, interface data representation) or process requirements (e.g. programming language, dev method, IDE);
			May be more critical than functional requirements; may affect overall architecture &amp; generate extra functional requirements;
			(problem: imprecision)(goal: reflects general intention of the user (e.g. ease of use /
			ability to recover from failure / rapid user response / minimize errors))
			(metrics: speed, size, ease of use, reliability, robustness, portability)
			<br>
			Requirements engineering process: <span class="semibold">elicitation &amp; analysis</span>
			stages: Interacting with stakeholders to discover &amp; understand their requirements;
			Groups unstructured collection of requirements, organizes them into coherent clusters;
			Prioritizing requirements, resolving conflicts;
			Document requirements, input them into the next round;
			(problems: stakeholders don't know what they really want, stakeholders express requirements in their own terms,
			conflicting requirements, organisational and political factors; requirements change during analysis)
			<br>
			<span class="semibold">Requirements discovery</span> methods:
			<span class="semibold">Ethnography/Observation</span> observe &amp; analyze how people work, no explanation required;
			may observe social and organisational factors;
			effective for understanding existing processes but cannot identify new features that should be added;
			<span class="semibold">Interview</span> types: Closed interviews, based on pre-determined list of questions; Open interviews,
			where various issues are explored;
			tips: be open-minded, avoid pre-conceived ideas; prompt the interviewee to get discussions;
			problems: not good for understanding domain requirements (requirements engineers cannot understand specific domain terminology);
			bad attitude; lack of research/basic understanding; no questions; unnecessary arguments on one matter;
			too many infeasible suggestions; no follow-up for previous suggestions
			<br>
			<span class="semibold">User stories and scenarios</span>
			User stories: real-life examples of how a system can be used;
			Scenario: description of how a system is used for a particular task (structured form of user story);
			<br>
			<span class="semibold">Requirements specification</span>
			process of writing down the user &amp; system requirements in a requirements document;
			user requirements have to be understandable by end-users &amp; customers without a technical background;
			system requirements are more detailed &amp; may include more technical information;
			may be part of a contract (needs to be as complete as possible);
			Forms: natural language, structured natural language, graphical notations, mathematical specifications
			Native language guidelines: invent a standard format for all requirements;
			use consistent language (e.g. "shall" for mandatory, "should" for desirable);
			highlight key parts; avoid heavily-technical terms;
			include an explanation/rationale about why a requirement is necessary;
			Problems: lack of clarity, confusion, amalgamation;
			<span class="semibold">Software requirements document</span> (aka Software Requirements Specification/SRS)
			the official statement of what is required of the system developers;
			should include both a definition of user requirements and a specification of the system requirements;
			<span class="semibold">Variability</span>
			document info depends on system type and development approach;
			structure: preface, intro, glossary, user requirements definition, system architecture,
			system requirements specification, system models, system evolution, appendices, index
			<br>
			<span class="semibold">Requirements validation</span>
			concerned with demonstrating that the requirements define the system
			that the customer really wants;
			requirements error costs are high so validation is very important;
			Checking: validity, consistency, completeness, realism, verifiability;
			Techniques: requirement reviews, prototyping, test case generation;
			<br>
			<span class="semibold">Requirements management</span>
			process of managing changing requirements during requirements engineering &amp; system development;
			keep track of individual requirements and maintain links between dependent requirements &amp; 
			establish a formal process for making change proposals and linking these to system requirements;
			deciding if a requirements change should be accepted
			</p>
			<hr>
			<h1>Design and Implementation</h1>
			<p>
				the stage where an executable software system is developed
				<span class="semibold">Object-oriented design process</span> involves developing different system models,
				may not be cost-effective for small systems, but is an important communication mechanism for large system
				developed by many groups; Common steps (involved model):
				Define the context and modes of use of the system (context/class, use case);
				Design the system architecture;
				Identify the principal system objects (object);
				Develop design models (sequence, state);
				Specify object interfaces
				<br>
				<span class="semibold">Implementation issues:</span>
				<span class="semibold">Reuse</span> levels: abstraction, object, component(collection of objects), system;
				costs: searching, buying, adaptation/configuration, integration
				<span class="semibold">Configuration management</span> general process of managing a changing software system,
				aimed to support the integration process so developers can access the project code and documents in a controlled way,
				find out what changes have been made, &amp; compile and link components to create a system;
				activities: version management, system building/integration (help define versions of components used to create each version of a system),
				Problem tracking/change management (allows users to report bugs/other problems, allow developers to see who is working on these problems &amp; when they are fixed)
				Release management (planning the functionality of new releases, organizing the software for distribution)
				<span class="semibold">Host-target development</span> (development vs. execution platform)
				dev platform tools: compiler + code editor, debugging system, graphical editor, testing tools, project support tools
				<br>
				<span class="semibold">Component/system deployment factors</span>
				component's hard/software requirements,
				system availability requirement (high availability systems may require components to be
				deployed on more than one platform; in the event of platform failure, an alternative
				implementation is available),
				Component communications (If there is a high level of communications between components, 
				deploy them on the same platform / platforms that are physically close to one other)
				<br>
				<span class="semibold">Open source development</span> business model: not selling software, but selling support
				(allows cheaper and quicker development &amp; creates a community of users);
				legally the developer(company/individual) still own the code &amp; can place restrictions on code usage
				<span class="semibold">License models</span> GPL (reciprocal, softwares using a GPL software must also be open-source),
				LGPL (allows components linking to open source code without publishing components source code),
				BSD (non-reciprocal, not obliged to publish changes/modifications to open source code)
				MIT (BSD variant)
			</p>
			<hr>
			<h1>UX design</h1>
			<p>
				a set of incremental process activities that focus on providing a positive experience for users;
				broader than UI design and usability/accessibility engineering
				<span class="semibold">Usability Guidelines</span>
				Anticipation, Communication, Consistency, Controlled autonomy, Efficiency,
				Flexibility, Focus, Human interface objects, Latency reduction, Learnability,
				Metaphors, Readability, Track state, Visible navigation
				<span class="semibold">Accessibility Guidelines</span>
				Application Accessibility, Response Time, Help Facilities, Error Handling,
				Menu and Command Labeling, Internationalization
			</p>
			<hr>
			<h1>Architectural design</h1>
			<p>
				critical link between design and requirements engineering;
				identifies the main structural components in a system and the relationships between them;
				this process outputs an architectural model
				<span class="semibold">Agility and architecture</span> an early stage of agile processes is to
				design an overall systems architecture, because refactoring architecture is usually expensive
				<br>
				<span class="semibold">Abstraction</span>
				in the small: the architecture of individual programs (how a program is decomposed into components)
				in the large: the architecture of complex enterprise systems (including other systems, programs, and program components)
				<br>
				<span class="semibold">Advantages of explicit architecture</span>
				Stakeholder communication, System analysis, Large-scale reuse
				<br>
				<span class="semibold">Architecture &amp; system characteristics</span>
				performance, maintainability, availability (redundant components &amp; mechanisms for fault tolerance),
				security (layered architecture with critical assets in the inner layers), 
				safety (localize safety-critical features in a small number of sub-systems)
				<br>
				<span class="semibold">Architectural patterns</span>
				a means of representing, sharing &amp; reusing knowledge;
				should include information about when they are/when they are not useful
				e.g. Model-View-Controller (MVC) pattern, Layered architecture pattern, Repository architecture pattern,
				Client-server architecture pattern
			</p>
			<hr>
			<h1>Design patterns</h1>
			<p>
				a way of reusing abstract knowledge about a problem and its solution;
				should be sufficiently abstract to be reused in different setting;
				usually make use of object-oriented characteristics
				<span class="semibold">elements</span> name, problem description, solution description
				(a template for a design solution that can be instantiated in different ways);
				consequences (results and trade-offs of applying the pattern)
				<br>
				<span class="semibold">Application architectures</span>
				designed to meet an organizational need
				(A generic application architecture is an architecture for a type of software system that may be
				configured &amp; adapted to create a system that meets specific requirements)
				e.g. Transaction processing systems, Information systems architecture
			</p>
			<hr>
			<h1>Testing</h1>
			<p>
				execute a program using artificial data;
				<span class="semibold">types</span> validation testing, to demonstrate that the software meets its requirements
				(at least one test for each requirement in custom software, each feature in general software);
				defect testing, to discover faults or defects in the software;
				<br>
				<span class="semibold">V &amp; V confidence</span> verification (conform to its specification) &amp;
				validation (do what the user really requires); aim to establish confidence that the system is fit for purpose;
				depends on software experience, user expectations, marketing environment
				<br>
				<span class="semibold">Inspections &amp; testing</span>
				inspection (static): involves examining the source representation, aimed to discover anomalies and defects; no execution;
				pros: no concern for interaction between errors, can inspect incomplete systems, can consider broader quality attributes
				(e.g. compliance with standards, portability &amp; maintainability);
				cons: cannot check unexpected interaction between parts, cannot check non-functional requirements
				<br>
				<span class="semibold">Stages of testing</span> Development/Release/User testing;
				<br>
				<span class="semibold">Development testing</span> includes unit/component/system testing;
				automated unit testing: unit testing frameworks provide generic test classes, extend to create specific test cases;
				consists of setup, call &amp; assertion part
				<br>
				<span class="semibold">Types of unit testing</span> one to reflect normal operation, one to check abnormal inputs processing
				<br>
				Testing strategies:
				<span class="semibold">Partition testing</span> identify groups of inputs with common characteristics &amp; should be processed in the same way;
				<span class="semibold">Coverage testing</span> execute/cover certain elements of a program;
				<span class="semibold">Guideline-based testing</span> <br>
				<span class="semibold">Black-box testing</span> based from the specification, no knowledge of code required;
				(cons: cannot test all possible inputs/outputs, some code parts might be unreachable, cannot check extra functionality)
				<span class="semibold">White-box testing</span> based on analysis of code (coverage-based testing approaches: statement, branch, path, loop)
				(cons: cannot check if a program matches the specification, cannot check if all functionalities have been implemented,
				cannot find missing program logic); <br>
				<span class="semibold">Testing guidelines</span>
				Try sequences with only one value; Use different-sized sequences across tests;
				Derive tests so that the first, middle and last elements of the sequence are accessed;
				Force the system to generate all error messages; Try to force an input buffer overflow;
				Repeat the same input/series of inputs numerous times; Force invalid outputs;
				Force invalid outputs; Force too large/small computation results
				<br>
				<span class="semibold">Component testing</span> focus on showing the component interface behaves according to specification;
				<span class="semibold">Interface types</span> parameter / shared memory / procedural (function call) / message passing (services);
				<span class="semibold">Interface errors</span> misuse/misunderstanding/timing error;
				<span class="semibold">Guidelines</span> Make parameters go at the extreme ends of their ranges;
				Test pointer parameters with nullptr; Try to cause a component failure; Use stress testing in message passing systems;
				In shared memory systems, vary the order of component activation
				<br>
				<span class="semibold">System testing</span>
				checks that components are compatible, interact correctly &amp; transfer the right data at the right time
				(Use-case testing: testing the use case to force these interactions to occur)
				<br>
				<span class="semibold">Test-driven development (TDD)</span>
				develop code incrementally, along with a test for that increment; (introduced as part of agile methods but also useable in plan-driven development)
				pros: code coverage, regression testing (testing to check that changes have not broken previously working code;
				simplified with automated testing),
				simplified debugging, system documentation
				<br>
				<span class="semibold">Release testing</span> test a release for a system intended for use outside of the development team;
				primary goal to convince the supplier of the system that it is good enough; a form of system testing, usually black-box,
				focuses on validation; strategies: requirement-based testing &amp; performance testing (should reflect the profile of use;
				use tests where load is steadily increases until performance is unacceptable; stress testing: deliberately overloads the system)
				<br>
				<span class="semibold">User/customer testing</span>
				types: alpha (users work with the development team, test at the developer's site);
				beta (users experiment with a system release, raise problems discovered with system developers);
				acceptance (customers test a system, decide whether it is ready to be accepted &amp; deployed in the customer environment;
				mainly for custom systems)
				<span class="semibold">Agile methods &amp; acceptance testing</span>
				user is part of the development team, responsible for making decisions on the system acceptability;
				tests are defined by the user/customer, automatically run for each change;
				no separate acceptance testing process;
				main problem: whether or not this user is 'typical' and represents all stakeholders' interests
			</p>
			<hr>
			<h1>Software Evolution</h1>
			<p>
				<span class="semibold">Importance</span> Revolution is required to maintain the value of business software systems;
				Majority of the software budget is devoted to changing &amp; evolving existing software
				<br>
				<span class="semibold">Evolution and servicing</span>
				Evolution: In operational use, evolving as new requirements are proposed and implemented in the system;
				Servicing: Small tactical changes to keep it operational, no new functionality added;
				Phase-out: Still used but no further changes
				<br>
				<span class="semibold">Change identification and evolution processes</span>
				Identification; Impact Analysis -> Accept or not; If accept, release planning
				(Fault repair, Environmental adaptation, System enhancement); Change Implementation
				<br>
				<span class="semibold">Change implementation</span>
				If changes implementation developer is not original system developer -> program understanding
				(how program is structured, how it delivers functionality, how changes might affect the program);
				If requirements specification and design documents are available, update documents;
				Proposed changes may be prototyped
				<br>
				<span class="semibold">Urgent change requests</span>
				may have to be implemented without going through all stages of the SE process
				(If a serious system fault has to be repaired to allow normaloperation to continue /
				If changes to the system's environment have unexpected effects /
				If there are business changes that require a very rapid response)
				<br>
				<span class="semibold">Agile methods and evolution</span>
				based on incremental development hence the seamless transition from development to evolution;
				Automated regression testing is particularly valuable;
				Changes may be expressed as additional user stories
				<br>
				Handover problems: development team uses Agile but evolution team prefers Plan-based -> needs detailed documentation;
				development team uses Plan-based but evolution team prefers Agile -> starts from scratch developing automated test and refactoring
				<br>
				<span class="semibold">Legacy systems</span> older systems that rely on languages and technology
				that are no longer used for new systems development (not limited to software)
				<br>
				<span class="semibold">Replacement</span> risky (lack of complete system specification,
				tight integration of system &amp; business processes,
				undocumented business rules, new software development may be late/over budget),
				expensive (inconsistent programming style, use of obsolete programming languages, inadequate documentation,
				structure degradation, hard-to-understand optimizations, data errors/duplication/inconsistency)
				<br>
				<span class="semibold">Software maintenance</span> Modifying a program after it has been put into use
				(normally no major changes to system architecture)
				types: Fault repairs, Environmental adaptation, Functionality addition and modification
			</p>
		</div>
	</body>
</html>